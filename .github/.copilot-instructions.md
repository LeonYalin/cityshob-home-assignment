# GitHub Copilot Instructions

## Project Overview
This is a Real-Time Todo Application built with:
- **Backend**: Node.js, TypeScript, Express.js, MongoDB/Mongoose, Socket.IO
- **Frontend**: Angular 18 (zoneless, standalone components)
- **Architecture**: Monorepo with npm workspaces, Class-based backend architecture

## Backend Architecture Patterns

### Classes vs Modules (IMPORTANT)
Follow these patterns strictly:

#### Use CLASSES for stateful components:
- **Services** - Business logic with dependencies (`TodoService`, `EmailService`)
- **Repositories** - Data access with connections (`MongoTodoRepository`, `InMemoryTodoRepository`)
- **Logger** - Logging service with context
- **Database Services** - Connection management
- **Custom Errors** - Error classes extending base Error

#### Use MODULES for stateless components:
- **Controllers** - HTTP endpoint handlers (stateless objects)
- **Middleware** - Request/response processors (pure functions)
- **Utilities** - Pure functions
- **Validators** - Stateless validation functions
- **Routes** - Express route definitions

### Dependency Injection Pattern
- Use **constructor injection** for classes
- Use **Factory pattern** for service creation
- Example:
```typescript
// Services as classes with DI
export class TodoService {
  constructor(
    private readonly todoRepository: ITodoRepository,
    private readonly logger: Logger
  ) {}
}

// Controllers as modules using factories
export const todoController = {
  getAllTodos: async (req, res, next) => {
    const todoService = await ServiceFactory.getTodoService();
    // ... implementation
  }
};
```

## File Naming Conventions

### Backend Files
- **Controllers**: `*.controller.ts` (e.g., `todo.controller.ts`) - **MODULES** (stateless objects)
- **Services**: `*.service.ts` (e.g., `todo.service.ts`) - **CLASSES** (with constructor DI)
- **Repositories**: `*.repository.ts` (e.g., `mongo-todo.repository.ts`) - **CLASSES** (data access)
- **Factories**: `*.factory.ts` (e.g., `service.factory.ts`) - **CLASSES** (dependency management)
- **Models**: `*.model.ts` (e.g., `todo.model.ts`) - Interfaces/Mongoose schemas
- **Routes**: `*.routes.ts` (e.g., `todo.routes.ts`) - **MODULES** (route definitions)
- **Middleware**: `*.middleware.ts` (e.g., `auth.middleware.ts`) - **MODULES** (functions)
- **Schemas**: `*.schema.ts` (e.g., `todo.schema.ts`) - Zod validation schemas
- **Errors**: `*.error.ts` (e.g., `validation.error.ts`) - **CLASSES** extending Error
- **Utils/Helpers**: `*.util.ts` or `*.helper.ts` - **MODULES** (pure functions)
- **Types**: `*.types.ts` (e.g., `api.types.ts`) - TypeScript interfaces

### Frontend Files
- **Components**: `*.component.ts` with corresponding `.component.html`, `.component.scss`
- **Services**: `*.service.ts` (e.g., `api.service.ts`, `websocket.service.ts`)
- **Guards**: `*.guard.ts` (e.g., `auth.guard.ts`)
- **Interceptors**: `*.interceptor.ts` (e.g., `auth.interceptor.ts`)
- **Pipes**: `*.pipe.ts` (e.g., `date.pipe.ts`)
- **Directives**: `*.directive.ts` (e.g., `highlight.directive.ts`)
- **Types/Interfaces**: `*.types.ts` or `*.interface.ts`

## Code Organization Rules

### Backend Structure
```
src/
├── controllers/     # HTTP request handlers (MODULES - stateless objects)
├── services/        # Business logic (CLASSES - with DI)
├── repositories/    # Data access layer (CLASSES - with connections)
│   ├── interfaces/  # Repository contracts
│   ├── mongo-*.repository.ts
│   ├── in-memory-*.repository.ts
│   └── *.factory.ts
├── models/          # Database models (Mongoose schemas + interfaces)
├── routes/          # Route definitions (MODULES - stateless)
├── middleware/      # Express middleware (MODULES - functions)
├── schemas/         # Validation schemas (Zod)
├── errors/          # Custom error classes (CLASSES)
├── utils/           # Utility functions (MODULES - pure functions)
├── types/           # TypeScript type definitions
└── server.ts        # Main application entry
```

### Frontend Structure
```
src/app/
├── components/      # Angular components
├── services/        # Angular services
├── guards/          # Route guards
├── interceptors/    # HTTP interceptors
├── pipes/           # Angular pipes
├── directives/      # Angular directives
├── types/           # TypeScript interfaces
└── app.ts           # Main application component
```

## Coding Standards

### TypeScript
- Use **strict mode** enabled
- Prefer **interfaces** over types for object shapes
- Use **enums** for constants with multiple values
- Always specify **return types** for functions
- Use **async/await** over Promises chains

### Architecture Patterns
- **Services**: Use classes with constructor injection
- **Repositories**: Implement interfaces, use classes for data access
- **Controllers**: Use stateless module objects
- **Middleware**: Use pure functions
- **Factory Pattern**: For dependency injection and service creation
- **Repository Pattern**: For data access abstraction

### Error Handling
- Create **custom error classes** extending base Error
- Use **proper HTTP status codes**
- Always **log errors** with context
- Provide **meaningful error messages**

### Validation
- Use **Zod schemas** for all input validation
- Validate at **controller level** before processing
- Separate **schemas** from **models**

### Database
- Use **Mongoose** for MongoDB operations
- Define **proper indexes** for performance
- Use **transactions** for multi-document operations
- Implement **soft deletes** where appropriate

### API Design
- Follow **RESTful conventions**
- Use **proper HTTP methods** (GET, POST, PUT, DELETE, PATCH)
- Implement **pagination** for list endpoints
- Use **consistent response formats**

### Logging
- Use **Logger class** with context injection
- Create logger instances: `new Logger('ContextName')`
- Include **request IDs** for tracing
- Log at appropriate levels (debug, info, warn, error)
- Never log **sensitive information**
- **Classes**: Use `this.logger` with constructor injection
- **Modules**: Create shared logger instances

### Security
- **Validate all inputs** before processing
- Use **CORS** appropriately
- Implement **rate limiting**
- **Sanitize** user inputs

## Socket.IO Conventions
- **Event names**: Use kebab-case (e.g., `todo-created`, `todo-updated`)
- **Namespaces**: Use for logical separation (e.g., `/todos`, `/notifications`)
- **Room naming**: Use consistent patterns (e.g., `todo:${todoId}`, `user:${userId}`)

## Testing Conventions
- **Test files**: `*.test.ts` or `*.spec.ts`
- **Mock files**: `*.mock.ts`
- Use **descriptive test names**
- Follow **AAA pattern** (Arrange, Act, Assert)

## Environment Variables
- Use **descriptive names** (e.g., `MONGODB_URI`, `JWT_SECRET`)
- Provide **default values** where appropriate
- Document all variables in `.env.example`

## Git Conventions
- **Commit messages**: Use conventional commits format
- **Branch names**: Use feature/fix/chore prefixes
- **PR titles**: Be descriptive and reference issues

## Performance Guidelines
- Use **database indexes** for frequent queries
- Implement **caching** where appropriate
- **Paginate** large result sets
- Use **connection pooling** for database
- **Compress** responses where beneficial

## Documentation
- Document **all public APIs**
- Use **JSDoc** for function documentation
- Keep **README** files updated
- Document **environment setup** steps

## Workspace Navigation Guidelines

### CRITICAL: Directory Navigation Requirements

#### Frontend Operations
**ALWAYS** change directory to `packages/frontend` before running any frontend commands:
```bash
cd packages/frontend
npm start
npm test
npm run build
# etc.
```

#### Backend Operations
**ALWAYS** change directory to `packages/backend` before running any backend commands:
```bash
cd packages/backend
npm start
npm test
npm run build
# etc.
```

### Testing Procedures

#### API Testing with Running Backend Server
When testing API endpoints while the backend server is running:

1. **Start backend server in one terminal:**
   ```bash
   cd packages/backend
   npm start
   ```

2. **Use a SEPARATE terminal for API testing:**
   ```bash
   # Open new terminal window/tab
   curl -X GET http://localhost:3000/api/todos
   # or use Postman, Insomnia, etc.
   ```

**❌ DO NOT run API tests in the same terminal as the running server** - this will shut down the server process.

### Common Mistakes to Avoid

1. **Running frontend commands from root directory** - will fail because package.json scripts are in packages/frontend
2. **Running backend commands from root directory** - will fail because package.json scripts are in packages/backend
3. **Testing APIs in server terminal** - will interrupt the running server process
4. **Forgetting to cd into correct package directory** - most common cause of "script not found" errors

### Recommended Development Workflow

1. Terminal 1: Backend server (`cd packages/backend && npm run dev`)
2. Terminal 2: Frontend server (`cd packages/frontend && npm start`)
3. Terminal 3: Available for testing/git commands

This setup allows for proper development workflow without interrupting running processes.